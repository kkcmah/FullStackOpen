currently learned about putting state and state logic in components
Redux library to manage state of larger applications
===part a flux-architecture and Redux===
Facebook developed flux to make state management easier
- state is stored separatly from components into their own stores
- state in store is not changed directly, but with actions
- when store state changes, view rerenders
Action => Dispatcher => Store => View
whole state of application is stored into one js object known as the store
different things in the state would be stored as separate fields of the object
actions are objects which have at least a field determining the type of action which changes state of the store
{type: "INCREMENT"}
impact of action to the state is defined using reducer.
reducer is a function which is given current state and action as params and returns new state
customary to use switchs instead of ifs in reducer
reducer is given as parameter to redux createStore function
import { createStore } from 'redux'
const store = createStore(counterReducer)
store uses reducer to handle actions with are sent with dispatch method
store.dispatch({type: 'INCREMENT'})
store.getState() to get store state
store.subscribe(callback) to create callbacks for store to call when state is changed
store.subscribe(() => {
  const storeNow = store.getState()
  console.log(storeNow)
})
actions may have type and field "data"
pure functions are those that do not cause any side effects and must always return the same response when called with same params
ex. use concat or [...state, action.data] instead of push()
reducer state must be composed of immutable objects
replace old object entirely with new
deep-freeze library to ensure that reducer is defined as immutable function
npm install --save-dev deep-freeze
uncontrolled forms are those that don't have state bound to them
functions that create actions are called action creators
hooks-api of the react-redux library to share redux store across app components
npm install react-redux
import { Provider } from 'react-redux'
 <Provider store={store}></Provider>
module can only have one default export, but multiple normal exports
import { createNote, toggleImportanceOf } from './reducers/noteReducer'
import { useSelector, useDispatch } from 'react-redux'
const dispatch = useDispatch()
const notes = useSelector(state => state)
dispatch(createNote(content))
actions called using useDispatch hook
can access states in store using useSelector hook
useSelector can search or select data from redux store
- const importantNotes = useSelector(state => state.filter(note => note.important))  
presentational component - simple and unaware that event handler it gets as props dispatches an action
container component - defines what event handlers of containing components does and coordinates configuration of presentation components
===part b many reducers===
same name attribute of radio buttons form a button group
combineReducers function to combine existing reducers when you have states in different properties
import { createStore, combineReducers } from 'redux'
const reducer = combineReducers({
  notes: noteReducer,
  filter: filterReducer
})
combined reducer works in such a way that every action gets handled in every part of the combined reducer (looks like action is duplicated)
redux toolkit library simplifies configuration of redux store and offers tools for easing state management
npm install @reduxjs/toolkit
use configureStore instead of createStore
import { configureStore } from '@reduxjs/toolkit'
const store = configureStore({
  reducer: {
    notes: noteReducer,
    filter: filterReducer
  }
})
^gets rid of combineReducers function
redux toolkit createSlice function to create reducers and related actions
import { createSlice } from '@reduxjs/toolkit'
const noteSlice = createSlice({
  name: 'notes',
  initialState,
  reducers: { 
    createNote(....),
    toggleImportanceOf(...)
  }
})
- name defines prefix used in action's type values
- ex. "notes/createNote"
-- use unique names among reducers
- initialState defines initial state
- reducers parameter takes reducer itself as object with functions that handles actions
-- action.payload now has the argument provided by calling action creator
dispatch(createNote('Redux Toolkit is awesome!'))
calls
dispatch({ type: 'notes/createNote', payload: 'Redux Toolkit is awesome!' })
state mutations allowed in createSlice
- Redux Toolkit utilizes Immer with reducers createde by createSlice which allows state mutations
- Immer uses mutated state to create new immutable state
- handy for updating complex state
createSlice function returns object containing reducer and action creators
  export const { createNote, toggleImportanceOf } = noteSlice.actions
  export default noteSlice.reducer
Redux DevTools chrome addon useful for inspecting redux store state and dispatch actions via console
- Redux tab in browser's console to use
===part c communicating with server in a redux application===
using json-server for development
script "server": "json-server -p3001 --watch db.json",
data in db.json
can add dispatch to useeffect dependency array when getting initial data for state to disable lint warning

