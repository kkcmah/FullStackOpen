Will be learning about GraphQL, Facebook's alternative to REST for communication between browser and server
===part a GraphQL - server===
REST is resource based and all resources has its own address which identifies it
ex. /users/10 and all operations done are via HTTP requests
complex data retrieval would take multiple REST requests oftentimes returning unnceccesary data in the process
principle of GraphQL is that browser code forms a query describing data wanted
all GraphQL queries are sent to the same address with type POST
heart of all GraphQL applications is a schema for describing data sent between client and server
    type Person {
        name: String!
        phone: String
        street: String!
        city: String!
        id: ID! 
    }
    type Query {
        personCount: Int!
        allPersons: [Person!]!
        findPerson(name: String!): Person
    }
String is a scalar type of GraphQL
exclamation mark denotes required field
ID is string but GraphQL ensures its uniqueness
schema describes what kind of params query can have, and what kind of data can be sent and received to and from the server
query {
  allPersons {
    name
    phone
  }
}
query must describe which fields of the object the query returns
non-exclamation mark means that return value can be null
will be using Apollo Server
npm install apollo-server graphql
const server = new ApolloServer({
  typeDefs,
  resolvers,
})
heart of code is ApolloServer which is given two parameters
typeDefs containing GraphQL schema
and resolves object which defines how GraphQL queries are responded to
When Apollo server is run in development mode the page http://localhost:4000 has a button Query your server that takes us to Apollo Studio Explorer.
^useful for making queries
resolve for ex. fetching single person
(root, args) => persons.find(p => p.name === args.name)
all resolver functions are given four parameters
Apollo defines default resolvers if we dont define ourselves
ex. default
    Person: {
        name: (root) => root.name,
        phone: (root) => root.phone,
        street: (root) => root.street,
        city: (root) => root.city,
        id: (root) => root.id
    }
if object saved do not have a certain field then default resolver is not sufficient and we have to define our own
ex. Person: {
    address: (root) => {
      return { 
        street: root.street,
        city: root.city
      }
    }
  }
whenever Person object is returned the other fields are returned using their default resolvers whereas address uses self-defined resolver
param root if the Person object so fields can be taken
Mutations are operations that cause a change ex. add person
type Mutation {
  addPerson(
    name: String!
    phone: String
    street: String!
    city: String!
  ): Person
}
Mutation is given details of person as params with phone being nullable
Mutation returns Person if successful and null if not successful
Mutation also requires a resolver
const resolvers = {
  // ...
  Mutation: {
    addPerson: (root, args) => {
      const person = { ...args, id: uuid() }
      persons = persons.concat(person)
      return person
    }
  }
}
some error handling is done via GraphQL validation but more complex cases handled by error handling mechanism of Apollo Server
const {UserInputError} = require("apollo-server")
//...
addPerson: (root, args) => {
      if (persons.find(p => p.name === args.name)) {
        throw new UserInputError('Name must be unique', {
          invalidArgs: args.name,
        })
      }
use enum to filter queries
query {
  allPersons(phone: YES) {
    name
    phone 
  }
}
enum YesNo {
  YES
  NO
}
....allPersons(phone: YesNo): [Person!]!....
resolver changes to
allPersons: (root, args) => {
    if (!args.phone) {
      return persons
    }
    const byPhone = (person) =>
      args.phone === 'YES' ? person.phone : !person.phone
    return persons.filter(byPhone)
  },
possible to combine multiple fields of type Query into one query
query {
  personCount
  allPersons {
    name
  }
}
can also use same query but supply different names
query {
  havePhone: allPersons(phone: YES){
    name
  }
  phoneless: allPersons(phone: NO){
    name
  }
}
beneficial to name queries expecially when queries or mutations have parameters
===part b React and GraphQL===
Relay by Facebook or Apollo Client to communicate with server from client
in new react project
note: apollo may not work with newest version of React either downgrade React or force update ignore
npm install @apollo/client graphql
import { ApolloClient, ApolloProvider, HttpLink, InMemoryCache, gql } from '@apollo/client'
const client = new ApolloClient({
  cache: new InMemoryCache(),
  link: new HttpLink({
    uri: 'http://localhost:4000',
  })
})
const query = gql'query { allPersons ....}
client.query({query}).then.....
app can communicate with server using client object
wrap App with <ApolloProvider client={client}>
useQuery hook to make queries
const ALL_PERSONS = gql`query {...
const result = useQuery(ALL_PERSONS)
useQuery returns object with multiple fields one is loading which is true if no response yet
result.data.allPersons contains data
use GraphQL variables to pass params dynamically
query findPersonByName($nameToSearch: String!) {
  findPerson(name: $nameToSearch) {
useLazyQuery or useQuery with option skip to execute query based on condition
const result = useQuery(FIND_PERSON, {
    variables: { nameToSearch },
    skip: !nameToSearch,
  })
Apollo client saves responses of queries to cache and will not send same query again
useMutation hook provides mutation making functionality
const CREATE_PERSON = gql`.....
const [ createPerson ] = useMutation(CREATE_PERSON)
createPerson({  variables: { name, phone, street, city } })
useMutation returns an array first being function to cause mutation
can make query poll to update cache
const result = useQuery(ALL_PERSONS, {
    pollInterval: 2000
^causes unncessary web traffic
can use refetchQueries param to run when new person is created
refetchQueries: [ { query: ALL_PERSONS } ]
can separate queries into own file queries.js:
export const CREATE_PERSON.... ALL_PERSON...
can register error handler function to useMutation's onError option
then use setError to set error
const [ createPerson ] = useMutation(CREATE_PERSON, {
  onError: (error) => {
      setError(error.graphQLErrors[0].message)
    }
if result of mutation is null GraphQL sees it as non error, but we can use result field to handle
const [ changeNumber, result ] = useMutation(EDIT_NUMBER)
in useEffect if (result.data && result.data.editNumber === null) deps array [result.data]
esLint warning about setError missing can just ignore line
